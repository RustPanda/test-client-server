// Мне в этом проекте нравятся только main. Mod server и client представляют сз себя большой спагетти код.
// Необходимо создать два "Класса" сервер и клиент. Логику h2, handle нового клиента и handle нового сообщения
// вынести в отдельные структуры, реализовать для них trait Tower.
// Логирование необходимо выделить в отдельный код, для сервера и клиента реалезовать middleware.
// Посмотреть в сторону crates логирования, например traising.

// Мне хотелось реализовать клиент-серверную архитектуру именно с использование низкоуровневых crates. Мне нравиться эта "наивная" реализация!)

// Я решил вынести серверную и клиентскую часть кода в отдельные модули. Подумал что так код станет выглядит чище:
mod client;
mod server;

// Объявим crates, которые я буду использовать в этом тестовом приложении:
use structopt::StructOpt;

// Определим структуру с trait StructOpt, она поможет нам понять с какой ролью мы запустили наше приложение:
#[derive(Debug, StructOpt)]
#[structopt(about = "Тестовое Client/Server приложение")]
enum Opt {
    Server(server::ServerOpt),
    Client(client::ClientOpt),
}

// Определим функцию main с использованиям макроса #[toki::main], main добжна быть async:
#[tokio::main]
async fn main() {
    match Opt::from_args() {
        Opt::Server(opt) => server::run(opt).await,
        Opt::Client(opt) => client::run(opt).await,
    };
}
